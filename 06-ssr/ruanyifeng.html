<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  async 函数是什么？一句话，它就是 Generator 函数的语法糖
  使得异步操作变得更加方便

  yield表达式就是暂停标志。

  调用函数,不执行,返回遍历器对象
  next()方法移动指针
  返回数据结构成员信息。具体来说，就是返回一个包含value和done两个属性的对象
  { value: 'hello', done: false }
  <script>
    let g1, g2;

    function* helloWorld() {
      yield 'hello';
      yield 'world';
      return "ending";
    }
    /* hw:遍历器对象
      调用 Generator 函数后，该函数并不执行，
      返回的也不是函数运行结果，而是一个指向内部状态的指针对象，
      遍历器对象
      遇到yield表达式，就暂停执行后面的操作，
      并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。
     */
    let hw = helloWorld();
    console.log('hw.next()', hw.next())



    // 一个例子,三维数组
    var arr = [
      1,
      [
        [2, 3], 4
      ],
      [
        5, 6
      ]
    ];
    // 需求,把这个三维数组变成一维的
    // 靠,怎么做到的,不懂不懂
    // 靠,怎么做到的,不懂不懂
    // 靠,怎么做到的,不懂不懂
    // 靠,怎么做到的,不懂不懂
    // yield表达式只能用在 Generator 函数里面
    // for 没有函数
    // forEach的参数是一个普通函数 
    // 所以for可以使用
    // 但是forEach不可以使用
    let flat = function* (arr) {
      for (let i = 0; i < arr.length; i++) {
        let item = arr[i];
        if (typeof item !== 'number') {
          yield* flat(item);
        } else {
          yield item
        }
      }
    }

    for (var f of flat(arr)) {
      console.log(f);
      // // 1, 2, 3, 4, 5, 6
    }
    console.log('flat(arr)', flat(arr))


    /* 
    yield表达式如果用在另一个表达式之中，必须放在圆括号里面。
      function* demo() {
        console.log('Hello' + yield); // SyntaxError
        console.log('Hello' + yield 123); // SyntaxError
        console.log('Hello' + (yield)); // OK
        console.log('Hello' + (yield 123)); // OK
      }  
      yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号。

       foo(yield 'a', yield 'b'); // OK
        let input = yield; // OK
    */

    /* 
      可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口
      var myIterable = {};
      myIterable[Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
      };

      Generator 函数执行后，返回一个遍历器对象。
      该对象本身也具有Symbol.iterator属性，执行后返回自身。
      function*gen()
      var g = gen();

      g[Symbol.iterator]() === g


      由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。
      V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。
     */

    /*  
        第二个看不懂了的了  
        这TM什么啊
    
    function wrapper(generatorFunction) {
        return function (...args) {
          let generatorObject = generatorFunction(...args);
          generatorObject.next();
          return generatorObject;
        };
      }

      const wrapped = wrapper(function* () {
        console.log(`First input: ${yield}`);
        return 'DONE';
      });

      wrapped().next('hello!')
     // First input: hello! */
    /* 
      斐波那契数列
      
     */
    function* fibonacci() {
      let [prev, curr] = [0, 1];
      for (;;) {
        yield curr;
        [prev, curr] = [curr, prev + curr]
      }
    }
    for (let n of fibonacci()) {
      if (n > 10) break;
      console.log(n)
    }

    // 这个也看不懂?什么是reflect

    // 通过Generator 为对象加上接口
    function* objectEntries(obj) {
      let propKeys = Reflect.ownKeys(obj);

      for (let propKey of propKeys) {
        yield [propKey, obj[propKey]];
      }
    }

    // 扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口

    // yield*表达式
    // 用来在一个 Generator 函数里面执行另一个 Generator 函数。

    /*  
        yield 'x';
        yield* foo();
        yield 'y';
     */
    // 等同于
    /* 
      yield 'x';
      yield 'a';
      yield 'b';
      yield 'y';
    */
    /* 
      function* g() {
        this.a = 11;
      }

      let obj = g();
      obj.next();
      obj.a // undefined
      g返回的总是遍历器对象，而不是this对象。
     */
  </script>
</body>

</html>